"use strict";(self.webpackChunkdaku=self.webpackChunkdaku||[]).push([[9169],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=c(a),d=r,h=p["".concat(s,".").concat(d)]||p[d]||u[d]||o;return a?n.createElement(h,i(i({ref:t},m),{},{components:a})):n.createElement(h,i({ref:t},m))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},4788:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const o={title:"Basics"},i=void 0,l={unversionedId:"Java/Basics",id:"Java/Basics",title:"Basics",description:"Java used for developing",source:"@site/docs/Java/Basics.md",sourceDirName:"Java",slug:"/Java/Basics",permalink:"/Java/Basics",draft:!1,tags:[],version:"current",frontMatter:{title:"Basics"},sidebar:"myAutogeneratedSidebar",previous:{title:"Jackson Intro",permalink:"/Jackson/Introduction"},next:{title:"IO",permalink:"/Java/IO"}},s={},c=[{value:"Java used for developing",id:"java-used-for-developing",level:3},{value:"Garbage Collector",id:"garbage-collector",level:3},{value:"Secure",id:"secure",level:3},{value:"JDK ,JRE, JVM",id:"jdk-jre-jvm",level:3},{value:"Is a Relationship",id:"is-a-relationship",level:3},{value:"Has a Relationship",id:"has-a-relationship",level:3},{value:"strictfp modifier",id:"strictfp-modifier",level:3},{value:"Java Document",id:"java-document",level:3},{value:"CompileTime Polimorphism",id:"compiletime-polimorphism",level:3},{value:"String",id:"string",level:3},{value:"StringBuffer",id:"stringbuffer",level:3},{value:"StringBuilder",id:"stringbuilder",level:3},{value:"Call by Value:",id:"call-by-value",level:3},{value:"Call by Reference (Not Applicable in Java):",id:"call-by-reference-not-applicable-in-java",level:3},{value:"Regex",id:"regex",level:3},{value:"Validations",id:"validations",level:3},{value:"Exception Types",id:"exception-types",level:3}],m={toc:c},p="wrapper";function u(e){let{components:t,...a}=e;return(0,r.kt)(p,(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"java-used-for-developing"},"Java used for developing"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Standalone Application(Windows based applications) using AWT and Swing."),(0,r.kt)("li",{parentName:"ul"},"Web Applications using Servlet, JSP, Struts, Spring, Hibernate, JSF"),(0,r.kt)("li",{parentName:"ul"},"Java SE (Java Standard Edition) - OOPs, String, Regex, Exception, Inner classes, Multithreading, I/O Stream, Networking, AWT, Swing, Reflection, Collection, etc"),(0,r.kt)("li",{parentName:"ul"},"Java EE (Java Enterprise Edition) - Servlet, JSP, Web Services, EJB, JPA, etc.")),(0,r.kt)("h3",{id:"garbage-collector"},"Garbage Collector"),(0,r.kt)("p",null,"programmers can\u2019t delete the objects. To delete or recollect that memory JVM has a program called Garbage Collector. Garbage Collectors can recollect the objects that are not referenced."),(0,r.kt)("h3",{id:"secure"},"Secure"),(0,r.kt)("p",null,"In java, we don\u2019t have pointers, so we cannot access out-of-bound arrays i.e it shows ArrayIndexOutOfBound Exception if we try to do so. That\u2019s why several security flaws like stack corruption or buffer overflow are impossible to exploit in Java. "),(0,r.kt)("h3",{id:"jdk-jre-jvm"},"JDK ,JRE, JVM"),(0,r.kt)("p",null,"![","[Pasted image 20231108220639.png]","]"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"JDK"),"(Java Development Kit): JDK is intended for software developers and includes development tools such as the Java compiler, Javadoc, Jar, and a debugger."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"JRE"),"(Java Runtime Environment): JRE contains the parts of the Java libraries required to run Java programs and is intended for end-users. JRE can be viewed as a subset of JDK."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"JVM:")," JVM (Java Virtual Machine) is an abstract machine. It is a specification that provides a runtime environment in which java bytecode can be executed. JVMs are available for many hardware and software platforms.")),(0,r.kt)("h3",{id:"is-a-relationship"},"Is a Relationship"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class{\n\nint name;\nint age;\n}\n")),(0,r.kt)("h3",{id:"has-a-relationship"},"Has a Relationship"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class{\n\nint name;\nint age;\n\n// variable of another class agregation\nAddress address;\n}\n")),(0,r.kt)("h3",{id:"strictfp-modifier"},"strictfp modifier"),(0,r.kt)("p",null,"Java strictfp keyword ensures that you will get the same result on every platform if you perform operations in the floating-point variable. The precision may differ from platform to platform that is why java programming language have provided the strictfp keyword, so that you get same result on every platform. So, now you have better control over the floating-point arithmetic. "),(0,r.kt)("h3",{id:"java-document"},"Java Document"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we must use the documentation comment /*",(0,r.kt)("em",{parentName:"li"},"... "),"/ to post information for the class, method, constructor, fields etc.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"javadoc M.java \n")),(0,r.kt)("h3",{id:"compiletime-polimorphism"},"CompileTime Polimorphism"),(0,r.kt)("p",null,"Methodoverridding\nStatic methods cant be overridden"),(0,r.kt)("h3",{id:"string"},"String"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Immutable (Cant be changed)"),(0,r.kt)("li",{parentName:"ul"},"Thread Safe")),(0,r.kt)("h3",{id:"stringbuffer"},"StringBuffer"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Mutable (Can be changed)"),(0,r.kt)("li",{parentName:"ul"},"Good For Multitreading."),(0,r.kt)("li",{parentName:"ul"},"Thread Safe"),(0,r.kt)("li",{parentName:"ul"},"Low performance"),(0,r.kt)("li",{parentName:"ul"},"If Multitreading is not required use StringBuilder")),(0,r.kt)("h3",{id:"stringbuilder"},"StringBuilder"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Mutable"),(0,r.kt)("li",{parentName:"ul"},"Not Thread Safe"),(0,r.kt)("li",{parentName:"ul"},"Better performance")),(0,r.kt)("p",null,'In Java, the terms "call by value" and "call by reference" refer to how arguments are passed to methods. However, it\'s important to note that Java strictly follows "call by value" semantics, and the concept of "call by reference" doesn\'t directly apply to Java.'),(0,r.kt)("h3",{id:"call-by-value"},"Call by Value:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In Java, when you pass a primitive data type (such as int, float, char, etc.) or an object reference as an argument to a method, you are passing the value of the variable. This means that a copy of the value is passed to the method, and any changes made to the parameter within the method do not affect the original variable outside the method."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class CallByValueExample {\n    public static void main(String[] args) {\n        int x = 10;\n        modifyValue(x);\n        System.out.println("Original value: " + x);  // Output: Original value: 10\n    }\n\n    static void modifyValue(int num) {\n        num = 20;\n        System.out.println("Modified value: " + num);  // Output: Modified value: 20\n    }\n}\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In the example above, the method ",(0,r.kt)("inlineCode",{parentName:"p"},"modifyValue")," receives a copy of the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),", and changes made to ",(0,r.kt)("inlineCode",{parentName:"p"},"num")," inside the method do not affect the original value of ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),"."))),(0,r.kt)("h3",{id:"call-by-reference-not-applicable-in-java"},"Call by Reference (Not Applicable in Java):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'In languages that support "call by reference," when you pass an object to a method, you are passing a reference to the original object. This means that changes made to the object inside the method are reflected in the original object outside the method.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},'However, Java strictly adheres to "call by value" semantics even for object references. When you pass an object reference to a method, a copy of the reference is passed, not the actual object. Therefore, changes made to the object\'s state inside the method are reflected in the original object, but reassigning the reference to a new object within the method does not affect the original reference.'),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class CallByReferenceExample {\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder("Hello");\n        modifyReference(sb);\n        System.out.println("Original reference: " + sb);  // Output: Original reference: Hello World\n    }\n\n    static void modifyReference(StringBuilder str) {\n        str.append(" World");\n        System.out.println("Modified reference: " + str);  // Output: Modified reference: Hello World\n    }\n}\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In this example, changes made to the ",(0,r.kt)("inlineCode",{parentName:"p"},"StringBuilder")," object inside the method are reflected in the original object, but if you reassign ",(0,r.kt)("inlineCode",{parentName:"p"},"str")," to a new ",(0,r.kt)("inlineCode",{parentName:"p"},"StringBuilder")," object, it doesn't affect the original reference."))),(0,r.kt)("h3",{id:"regex"},"Regex"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'MatchResult interface\nMatcher class\nPattern class\nPatternSyntaxException class\n\n\n    boolean p= Pattern.compile(".s").matcher("ass").matches();\n    \n    boolean q = Pattern.matches(".S", "AS");\n\n    boolean or = Pattern.matches("[abc]", "c"); //either a or b or c ones\n    \n')),(0,r.kt)("h3",{id:"validations"},"Validations"),(0,r.kt)("p",null,"1\t","[abc]","\ta, b, or c (simple class)\n2\t",(0,r.kt)("sup",{parentName:"p",id:"fnref-abc"},(0,r.kt)("a",{parentName:"sup",href:"#fn-abc",className:"footnote-ref"},"abc")),"\tAny character except a, b, or c (negation)\n3\t","[a-zA-Z]","\ta through z or A through Z, inclusive (range)\n4\t[a-d","[m-p]","]\ta through d, or m through p: ","[a-dm-p]"," (union)\n5\t[a-z&&","[def]","]\td, e, or f (intersection)\n6\t[a-z&&",(0,r.kt)("sup",{parentName:"p",id:"fnref-bc"},(0,r.kt)("a",{parentName:"sup",href:"#fn-bc",className:"footnote-ref"},"bc")),"]\ta through z, except for b and c: ","[ad-z]","\n7\t[a-z&&",(0,r.kt)("sup",{parentName:"p",id:"fnref-m-p"},(0,r.kt)("a",{parentName:"sup",href:"#fn-m-p",className:"footnote-ref"},"m-p")),"]\ta through z, and not m through p: a-lq-z"),(0,r.kt)("p",null,"The quantifiers specify the number of occurrences of a character.\nRegex\tDescription\nX?\tX occurs once or not at all\nX+\tX occurs once or more times\nX*\tX occurs zero or more times\nX{n}\tX occurs n times only\nX{n,}\tX occurs n or more times\nX{y,z}\tX occurs at least y times but less than z times"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'    import java.util.regex.*;  \n    class RegexExample4{  \n    public static void main(String args[]){  \n    System.out.println("? quantifier ....");  \n    System.out.println(Pattern.matches("[amn]?", "a"));//true (a or m or n comes one time)  \n    System.out.println(Pattern.matches("[amn]?", "aaa"));//false (a comes more than one time)  \n    System.out.println(Pattern.matches("[amn]?", "aammmnn"));//false (a m and n comes more than one time)  \n    System.out.println(Pattern.matches("[amn]?", "aazzta"));//false (a comes more than one time)  \n    System.out.println(Pattern.matches("[amn]?", "am"));//false (a or m or n must come one time)  \n      \n    System.out.println("+ quantifier ....");  \n    System.out.println(Pattern.matches("[amn]+", "a"));//true (a or m or n once or more times)  \n    System.out.println(Pattern.matches("[amn]+", "aaa"));//true (a comes more than one time)  \n    System.out.println(Pattern.matches("[amn]+", "aammmnn"));//true (a or m or n comes more than once)  \n    System.out.println(Pattern.matches("[amn]+", "aazzta"));//false (z and t are not matching pattern)  \n      \n    System.out.println("* quantifier ....");  \n    System.out.println(Pattern.matches("[amn]*", "ammmna"));//true (a or m or n may come zero or more times)  \n      \n    }}  \n\n')),(0,r.kt)("p",null,"Regex Metacharacters"),(0,r.kt)("p",null,"The regular expression metacharacters work as shortcodes.\nRegex\tDescription\n.\tAny character (may or may not match terminator)\n\\d\tAny digits, short of ","[0-9]","\n\\D\tAny non-digit, short for ",(0,r.kt)("sup",{parentName:"p",id:"fnref-0-9"},(0,r.kt)("a",{parentName:"sup",href:"#fn-0-9",className:"footnote-ref"},"0-9")),"\n\\s\tAny whitespace character, short for ","[\\t\\n\\x0B\\f\\r]","\n\\S\tAny non-whitespace character, short for ",(0,r.kt)("sup",{parentName:"p",id:"fnref-\\s"},(0,r.kt)("a",{parentName:"sup",href:"#fn-\\s",className:"footnote-ref"},"\\s")),"\n\\w\tAny word character, short for ","[a-zA-Z_0-9]","\n\\W\tAny non-word character, short for ",(0,r.kt)("sup",{parentName:"p",id:"fnref-\\w"},(0,r.kt)("a",{parentName:"sup",href:"#fn-\\w",className:"footnote-ref"},"\\w")),"\n\\b\tA word boundary\n\\B\tA non word boundary"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'    import java.util.regex.*;  \n    class RegexExample5{  \n    public static void main(String args[]){  \n    System.out.println("metacharacters d....");\\\\d means digit  \n      \n    System.out.println(Pattern.matches("\\\\d", "abc"));//false (non-digit)  \n    System.out.println(Pattern.matches("\\\\d", "1"));//true (digit and comes once)  \n    System.out.println(Pattern.matches("\\\\d", "4443"));//false (digit but comes more than once)  \n    System.out.println(Pattern.matches("\\\\d", "323abc"));//false (digit and char)  \n      \n    System.out.println("metacharacters D....");\\\\D means non-digit  \n      \n    System.out.println(Pattern.matches("\\\\D", "abc"));//false (non-digit but comes more than once)  \n    System.out.println(Pattern.matches("\\\\D", "1"));//false (digit)  \n    System.out.println(Pattern.matches("\\\\D", "4443"));//false (digit)  \n    System.out.println(Pattern.matches("\\\\D", "323abc"));//false (digit and char)  \n    System.out.println(Pattern.matches("\\\\D", "m"));//true (non-digit and comes once)  \n      \n    System.out.println("metacharacters D with quantifier....");  \n    System.out.println(Pattern.matches("\\\\D*", "mak"));//true (non-digit and may come 0 or more times)  \n      \n    }}\n\n')),(0,r.kt)("h3",{id:"exception-types"},"Exception Types"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Checked Exception\nUnchecked Exception\nError\n")))}u.isMDXComponent=!0}}]);